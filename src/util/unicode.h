// -*- mode: c++; -*-

#ifndef FREESPACE2_UTILS_UNICODE_H
#define FREESPACE2_UTILS_UNICODE_H

// UTFCPP library inline, copyright 2006 Nemanja Trifunovic

/*
Permission is hereby granted, free of charge, to any person or organization
obtaining a copy of the software and accompanying documentation covered by
this license (the "Software") to use, reproduce, display, distribute,
execute, and transmit the Software, and to prepare derivative works of the
Software, and to permit third-parties to whom the Software is furnished to
do so, all subject to the following:
The copyright notices in the Software and this entire statement, including
the above license grant, this restriction and the following disclaimer,
must be included in all copies of the Software, in whole or in part, and
all derivative works of the Software, unless such copies or derivative
works are solely in the form of machine-executable object code generated by
a source language processor.
THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE, TITLE AND NON-INFRINGEMENT. IN NO EVENT
SHALL THE COPYRIGHT HOLDERS OR ANYONE DISTRIBUTING THE SOFTWARE BE LIABLE
FOR ANY DAMAGES OR OTHER LIABILITY, WHETHER IN CONTRACT, TORT OR OTHERWISE,
ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
DEALINGS IN THE SOFTWARE.
*/

#include "globalincs/pstypes.h"

#include "mod_table/mod_table.h"

#include <cinttypes>
#include <iterator>
#include <stdexcept>

namespace unicode {
namespace detail {

enum utf_error {
    UTF8_OK,
    NOT_ENOUGH_ROOM,
    INVALID_LEAD,
    INCOMPLETE_SEQUENCE,
    OVERLONG_SEQUENCE,
    INVALID_CODE_POINT
};

const uint16_t LEAD_SURROGATE_MIN = 0xd800u;
const uint16_t TRAIL_SURROGATE_MAX = 0xdfffu;
const uint32_t CODE_POINT_MAX = 0x0010ffffu;

template< typename octet_type >
inline uint8_t mask8 (octet_type c) {
    return static_cast< uint8_t > (0xff & c);
}

template< typename T >
inline bool is_surrogate (T c) {
    return c >= LEAD_SURROGATE_MIN && c <= TRAIL_SURROGATE_MAX;
}

template< typename T >
inline bool is_code_point_valid (T c) {
    return c <= CODE_POINT_MAX && !is_surrogate (c);
}

template< typename octet_type >
inline bool is_trail (octet_type oc) {
    return ((mask8 (oc) >> 6) == 0x2);
}

template< typename DifferenceType >
inline bool is_overlong_sequence (uint32_t c, DifferenceType length) {
    if (c < 0x80) {
        if (length != 1) return true;
    }
    else if (c < 0x800) {
        if (length != 2) return true;
    }
    else if (c < 0x10000) {
        if (length != 3) return true;
    }

    return false;
}

template< typename InputIterator >
InputIterator append (uint32_t c, InputIterator iter) {
    if (!is_code_point_valid (c))
        throw std::runtime_error ("invalid_code_point");

    if (c < 0x80) // one octet
        *iter++ = static_cast< uint8_t > (c);
    else if (c < 0x800) { // two octets
        *iter++ = static_cast< uint8_t > ((c >> 6) | 0xc0);
        *iter++ = static_cast< uint8_t > ((c & 0x3f) | 0x80);
    }
    else if (c < 0x10000) { // three octets
        *iter++ = static_cast< uint8_t > ((c >> 12) | 0xe0);
        *iter++ = static_cast< uint8_t > (((c >> 6) & 0x3f) | 0x80);
        *iter++ = static_cast< uint8_t > ((c & 0x3f) | 0x80);
    }
    else { // four octets
        *iter++ = static_cast< uint8_t > ((c >> 18) | 0xf0);
        *iter++ = static_cast< uint8_t > (((c >> 12) & 0x3f) | 0x80);
        *iter++ = static_cast< uint8_t > (((c >> 6) & 0x3f) | 0x80);
        *iter++ = static_cast< uint8_t > ((c & 0x3f) | 0x80);
    }
    return iter;
}

template< typename octet_iterator >
inline typename std::iterator_traits< octet_iterator >::difference_type
sequence_length (octet_iterator lead_it) {
    uint8_t lead = mask8 (*lead_it);

    if (lead < 0x80)
        return 1;
    else if ((lead >> 5) == 0x6)
        return 2;
    else if ((lead >> 4) == 0xe)
        return 3;
    else if ((lead >> 3) == 0x1e)
        return 4;
    else
        return 0;
}

template< typename octet_iterator >
utf_error increase_safely (octet_iterator& it, octet_iterator end) {
    if (++it == end) return NOT_ENOUGH_ROOM;

    if (!is_trail (*it)) return INCOMPLETE_SEQUENCE;

    return UTF8_OK;
}

#define UTF8_CPP_INCREASE_AND_RETURN_ON_ERROR(a, b) \
    {                                               \
        utf_error ret = increase_safely (a, b);     \
        if (ret != UTF8_OK) return ret;             \
    }

/// get_sequence_x functions decode utf-8 sequences of the length x
template< typename octet_iterator >
utf_error
get_sequence_1 (octet_iterator& it, octet_iterator end, uint32_t& code_point) {
    if (it == end) return NOT_ENOUGH_ROOM;

    code_point = mask8 (*it);

    return UTF8_OK;
}

template< typename octet_iterator >
utf_error
get_sequence_2 (octet_iterator& it, octet_iterator end, uint32_t& code_point) {
    if (it == end) return NOT_ENOUGH_ROOM;

    code_point = mask8 (*it);

    UTF8_CPP_INCREASE_AND_RETURN_ON_ERROR (it, end);
    code_point = ((code_point << 6) & 0x7ff) + ((*it) & 0x3f);

    return UTF8_OK;
}

template< typename octet_iterator >
utf_error
get_sequence_3 (octet_iterator& it, octet_iterator end, uint32_t& code_point) {
    if (it == end) return NOT_ENOUGH_ROOM;

    code_point = mask8 (*it);

    UTF8_CPP_INCREASE_AND_RETURN_ON_ERROR (it, end);
    code_point = ((code_point << 12) & 0xffff) + ((mask8 (*it) << 6) & 0xfff);

    UTF8_CPP_INCREASE_AND_RETURN_ON_ERROR (it, end);
    code_point += (*it) & 0x3f;

    return UTF8_OK;
}

template< typename octet_iterator >
utf_error
get_sequence_4 (octet_iterator& it, octet_iterator end, uint32_t& code_point) {
    if (it == end) return NOT_ENOUGH_ROOM;

    code_point = mask8 (*it);

    UTF8_CPP_INCREASE_AND_RETURN_ON_ERROR (it, end);
    code_point =
        ((code_point << 18) & 0x1fffff) + ((mask8 (*it) << 12) & 0x3ffff);

    UTF8_CPP_INCREASE_AND_RETURN_ON_ERROR (it, end);
    code_point += (mask8 (*it) << 6) & 0xfff;

    UTF8_CPP_INCREASE_AND_RETURN_ON_ERROR (it, end);
    code_point += (*it) & 0x3f;

    return UTF8_OK;
}

#undef UTF8_CPP_INCREASE_AND_RETURN_ON_ERROR

template< typename InputIterator >
inline utf_error
validate_next (InputIterator& it, InputIterator end, uint32_t& code_point) {
    if (it == end) return NOT_ENOUGH_ROOM;

    // Save the original value of it so we can go back in case of failure
    // Of course, it does not make much sense with i.e. stream iterators
    InputIterator save = it;

    uint32_t cp = 0;

    // Determine the sequence length based on the lead octet
    typedef typename std::iterator_traits< InputIterator >::difference_type
        octet_difference_type;

    const octet_difference_type length = sequence_length (it);

    // Get trail octets and calculate the code point
    utf_error err = UTF8_OK;

    switch (length) {
    case 0: return INVALID_LEAD;
    case 1: err = get_sequence_1 (it, end, cp); break;
    case 2: err = get_sequence_2 (it, end, cp); break;
    case 3: err = get_sequence_3 (it, end, cp); break;
    case 4: err = get_sequence_4 (it, end, cp); break;
    }

    if (err == UTF8_OK) {
        // Decoding succeeded. Now, security checks...
        if (is_code_point_valid (cp)) {
            if (!is_overlong_sequence (cp, length)) {
                // Passed! Return here.
                code_point = cp;
                ++it;
                return UTF8_OK;
            }
            else
                err = OVERLONG_SEQUENCE;
        }
        else
            err = INVALID_CODE_POINT;
    }

    return it = save, err;
}

template< typename InputIterator >
inline utf_error validate_next (InputIterator& it, InputIterator end) {
    uint32_t ignored;
    return validate_next (it, end, ignored);
}

template< typename InputIterator >
uint32_t next (InputIterator& it, InputIterator end) {
    uint32_t c = 0;
    auto errc = validate_next (it, end, c);

    switch (errc) {
    case UTF8_OK: break;

    case NOT_ENOUGH_ROOM: throw std::runtime_error ("not_enough_room");

    case INVALID_LEAD:
    case INCOMPLETE_SEQUENCE:
    case OVERLONG_SEQUENCE: throw std::runtime_error ("invalid_utf8");

    case INVALID_CODE_POINT: throw std::runtime_error ("invalid_code_point");
    }

    return c;
}

template< typename octet_iterator >
uint32_t peek_next (octet_iterator it, octet_iterator end) {
    return detail::next (it, end);
}

template< typename octet_iterator >
uint32_t prior (octet_iterator& it, octet_iterator start) {
    // can't do much if it == start
    if (it == start) throw std::runtime_error ("not_enough_room");

    octet_iterator end = it;

    // Go back until we hit either a lead octet or start
    while (is_trail (*(--it))) {
        if (it == start)
            // error - no lead byte in the sequence
            throw std::runtime_error ("invalid_utf8");
    }

    return peek_next (it, end);
}

template< typename InputIterator >
typename std::iterator_traits< InputIterator >::difference_type
distance (InputIterator iter, InputIterator last) {
    typename std::iterator_traits< InputIterator >::difference_type n;

    for (n = 0; iter < last; ++n) {
        // TODO: check return value
        next (iter, last);
    }

    return n;
}

template< typename InputIterator, typename DistanceType >
void advance (InputIterator& it, DistanceType n, InputIterator end) {
    for (DistanceType i = 0; i < n; ++i) next (it, end);
}

template< typename octet_iterator >
octet_iterator find_invalid (octet_iterator start, octet_iterator end) {
    octet_iterator result = start;

    while (result != end) {
        utf_error errc = validate_next (result, end);

        if (errc != UTF8_OK) return result;
    }

    return result;
}

inline size_t encoded_width (uint32_t c) {
    if (!is_code_point_valid (c))
        throw std::runtime_error ("invalid_code_point");

    if (c < 0x80) // one octet
        return 1;
    else if (c < 0x800) // two octets
        return 2;
    else if (c < 0x10000) // three octets
        return 3;
    else // four octets
        return 4;
}

} // namespace detail

/**
 * @brief A standard unicode codepoint
 */
typedef char32_t codepoint_t;

class text_iterator {
    const char* current_byte = nullptr;
    const char* range_end_byte = nullptr;
    const char* range_start_byte = nullptr;

    bool is_from_same_range (const text_iterator& other) const;

public:
    explicit text_iterator (
        const char* current_byte, const char* range_start_byte,
        const char* range_end_byte = nullptr);

    typedef codepoint_t value_type;

    const char* pos () const;

    text_iterator& operator++ ();
    text_iterator& operator-- ();

    value_type operator* ();

    bool operator== (const text_iterator& rhs) const;
    bool operator!= (const text_iterator& rhs) const;

    bool operator< (const text_iterator& rhs) const;
    bool operator> (const text_iterator& rhs) const;
    bool operator<= (const text_iterator& rhs) const;
    bool operator>= (const text_iterator& rhs) const;

    text_iterator operator+ (ptrdiff_t diff) const;
    text_iterator operator- (ptrdiff_t diff) const;
};

/**
 * @brief Represents a range of unicode codepoints that can be iterated over
 *
 * @note This class can be used in range based for loops
 */
class codepoint_range {
    const char* start = nullptr;
    const char* end_ptr = nullptr;

public:
    /**
     * @brief Creates a codepoint range based on an UTF-8 encoded string
     * @param start The start of the encoded string
     * @param end The end of the encoded string. May be @c nullptr in which
     * case @c start is assumed to be null-terminated
     */
    explicit codepoint_range (const char* start, const char* end = nullptr);

    /**
     * @brief Retrieves an iterator for the start of the codepoint range
     * @return An iterator which is located at the start of the range
     */
    text_iterator begin ();

    /**
     * @brief Retrieves an iterator for the end of the codepoint range
     * @return An iterator which is located at the end of the range
     */
    text_iterator end ();
};

/**
 * @brief Computes the byte size the given codepoint would have if it were
 * encoded using the standard encoding
 *
 * The standard encoding is UTF-8 in Unicode mode and ASCII otherwise.
 *
 * @param cp The codepoint to determine the size for.
 * @return The number of bytes required for encoding this code point.
 */
size_t encoded_size (codepoint_t cp);

/**
 * @brief Appends the given code point to the byte range specified by buffer.
 *
 * @c buffer can be a pointer to a character buffer or an output iterator. If
 * the engine is in Unicode mode then the codepoint will be encoded using
 * UTF-8. Otherwise the codepoint will be truncated to fit into the ASCII
 * encoding.
 *
 * @tparam octet_iterator The type of the output sequence.
 * @param cp The codepoint to encode
 * @param buffer The buffer to write the encoded data to.
 * @return The value of the iterator after appending all bytes to the sequence.
 */
template< typename octet_iterator >
octet_iterator encode (codepoint_t cp, octet_iterator buffer) {
    if (Unicode_text_mode) {
        try {
            return detail::append (cp, buffer);
        }
        catch (const std::exception& e) {
            ASSERTX (0, "Exception while encoding Unicode code point %" PRIu32 ": %s",(uint32_t)cp, e.what ());
            return buffer;
        }
    }
    else {
        // In the legacy mode every code point is exactly one char
        *(buffer++) = (char)cp;
        return buffer;
    }
}

/**
 * @brief Counts the number of code points in the specified byte sequence
 *
 * @note This respects the Unicode mod setting and should be used where the
 * text contains Unicode characters.
 *
 * @tparam octet_iterator The type of the byte sequence.
 * @param start An iterator located at the start of the sequence
 * @param end An iterator which signals the end of the sequence
 * @return The number of codepoints found between @c start and @c end
 */
template< typename octet_iterator >
size_t num_codepoints (octet_iterator start, octet_iterator end) {
    if (Unicode_text_mode) {
        try {
            return static_cast< size_t > (detail::distance (start, end));
        }
        catch (const std::exception& e) {
            ASSERTX (0, "Exception while counting Unicode code points: %s",e.what ());
            return 0;
        }
    }
    else {
        return static_cast< size_t > (std::distance (start, end));
    }
}

template< typename octet_iterator >
void advance (octet_iterator& start, size_t n, octet_iterator end) {
    if (Unicode_text_mode) { detail::advance (start, n, end); }
    else {
        start = std::min (start + n, end);
    }
}

} // namespace unicode

#endif // FREESPACE2_UTILS_UNICODE_H
